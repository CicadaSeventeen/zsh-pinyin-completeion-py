import socket
import os
import signal
import sys
import completion as cmplt
import json

def main():
    # 定义socket文件路径
    XDG_RUNTIME_DIR = os.environ.get("XDG_RUNTIME_DIR")
    SHELL_PID = os.getppid()
    global socket_path
    socket_path = XDG_RUNTIME_DIR + '/' + str(SHELL_PID)
    # 清理可能存在的旧socket文件
    if os.path.exists(socket_path):
        os.unlink(socket_path)
    # 创建Unix Domain Socket
    try:
        server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        server.bind(socket_path)
        server.listen(1)
        signal.signal(signal.SIGINT, cleanup)
        signal.signal(signal.SIGTERM, cleanup)
    except Exception as e:
        sys.stderr.write(f"Server Error: {e}")
    try:
        while True:
            client, addr = server.accept()
    # 接收客户端数据
            client_data = client.recv(4096).decode().split('\n')
            try:
                os.environ.update(json.loads(client_data[2]))
            except:
                pass
            #print(client_data[0],client_data[1])
            string_return = cmplt.main(target=client_data[0],path=client_data[1])
    # 向客户端发送数据
            server_data = string_return.encode()
            client.send(server_data)
            client.close()
    except:
        cleanup(2)

def cleanup(signum, frame=None):
    if signum == 2 or signum == 15:
        try:
            server.close()
        except:
            pass
        if os.path.exists(socket_path):
            os.unlink(socket_path)
        sys.exit(0)


if __name__ == "__main__":
    if sys.platform.startswith('linux'):
        import ctypes
        import ctypes.util
        libc = ctypes.CDLL(ctypes.util.find_library('c'))
        libc.prctl(1, signal.SIGTERM)
    main()
